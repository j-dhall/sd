apply plugin: 'java'
apply plugin: 'war'

buildscript {
	repositories {
		gradlePluginPortal()
	}
	dependencies {
		classpath 'com.bmuschko:gradle-tomcat-plugin:2.7.0'
	}
}

//apply plugin: 'jetty'
apply plugin: 'com.bmuschko.tomcat'

repositories {
    mavenCentral()
}

dependencies {
    providedCompile 'javax.servlet:servlet-api:2.5',
            'javax.servlet.jsp:jsp-api:2.1'
    runtime 'javax.servlet:jstl:1.1.2',
            'taglibs:standard:1.1.2'
}

dependencies {
    def tomcatVersion = '9.0.1'
    tomcat "org.apache.tomcat.embed:tomcat-embed-core:${tomcatVersion}",
           "org.apache.tomcat.embed:tomcat-embed-logging-juli:9.0.0.M6",
           "org.apache.tomcat.embed:tomcat-embed-jasper:${tomcatVersion}"
}

tomcat {
    httpProtocol = 'org.apache.coyote.http11.Http11Nio2Protocol'
    ajpProtocol  = 'org.apache.coyote.ajp.AjpNio2Protocol'
}

setDescription("TODO Web Application demonstrating Gradle capabilities")
println "Description of $name: " + project.description

//Ch 1: task demo - BEGIN
task startSession (group: 'INITIALIZATION') {
	doLast {
		chant()
	}
}

def chant() {
	ant.echo(message: 'Repeat after me...')
}

3.times {
	task "yayGradle$it" {
		doLast {
			println 'Gradle rocks'
		}
	}
}

yayGradle0.dependsOn startSession
yayGradle2.dependsOn yayGradle1, yayGradle0
task groupTherapy(dependsOn: yayGradle2)
//Ch 1: task demo - END

//Sec 4.2.2: version task demo  - BEGIN

version = '0.1-SNAPSHOT'

task printVersion {
	group = 'Versioning'
	description = 'Prints project version.'
	
	
	doFirst {
		println "Before reading project version"
	}
	doLast {
		println "Version: $version"
	}
}

printVersion.doFirst {println "First action"}
printVersion.doFirst {println "Prior se bhee pehle action"}
printVersion.doLast {println "antimm task"}

//Sec 4.2.2: version task demo  - END

//4.2.6 Version format into Major Minor Released ReadFromFile BEGIN
version = new ProjectVersion(0, 1)

class ProjectVersion {
	Integer major
	Integer minor
	Boolean release
	
	ProjectVersion(Integer major, Integer minor) {
		this.major = major
		this.minor = minor
		this.release = Boolean.FALSE
	}
	
	ProjectVersion(Integer major, Integer minor, Boolean release) {
		this(major, minor)
		this.release = release
	}
	
	@Override
	String toString() {
		"$major.$minor${release ? '' : '-SNAPSHOT'}"
	}
}

ext.versionFile = file('version.properties')

task loadVersion {
	//task configuration
	project.version = readVersion()
}
ProjectVersion readVersion() {
	//open file
	logger.quiet 'Reading the version file.'
	if(!versionFile.exists()) {
		throw new GradleException("Required version file does not exist: $versionFile.canonicalPath")
	}
	//read content in stream and convert stream to properties map
	Properties versionProps = new Properties()
	versionFile.withInputStream {stream -> versionProps.load(stream)}
	//create an instance of ProjectVersion with values from properties map
	new ProjectVersion(versionProps.major.toInteger(),
						versionProps.minor.toInteger(),
						versionProps.release.toBoolean())
}

//4.2.6 Version format into Major Minor Released ReadFromFile END

//4.2.8 Set release=true, task UP-TO-DATE using inputs/outputs checksum BEGIN
task makeReleaseVersion(group: 'versioning', description: 'Makes project a release version.') {
	inputs.property('release', version.release)
	outputs.file versionFile

	doLast {
		version.release = true
		ant.propertyfile(file: versionFile) {
		entry(key: 'release', type: 'string', operation: '=', value: 'true')
		}
	}
}
//4.2.8 Set release=true, task UP-TO-DATE using inputs/outputs checksum END

//4.2.9 Task class BEGIN
class ReleaseVersionTask extends DefaultTask {
	@Input Boolean release
	@OutputFile File destFile

	ReleaseVersionTask() {
		group = 'versioning'
		description = 'Makes project a release version.'
	}

	@TaskAction
	void start() {
		project.version.release = true
		ant.propertyfile(file: destFile) {
			entry(key: 'release', type: 'string', operation: '=', value: 'true')
		}
	}
}

task makeReleaseVersion2(type: ReleaseVersionTask) {
	release = version.release
	destFile = versionFile
}
//4.2.9 Task class END

//4.2.10 backup releases for restore of previous release during new release failure BEGIN
task createDistribution(type: Zip, dependsOn: makeReleaseVersion2) {
	from war.outputs.files
	from(sourceSets*.allSource) {
		into 'src'
	}
	from(rootDir) {
		include versionFile.name
	}
}

task backupReleaseDistribution(type: Copy) {
	from createDistribution.outputs.files
	into "$buildDir/backup"
}

task release(dependsOn: backupReleaseDistribution) {
	doLast {
		logger.quiet 'Releasing the project...'
	}
}

//4.2.10 backup releases for restore of previous release during new release failure END

//4.2.11 Task Rules BEGIN
tasks.addRule("Pattern: increment<Classifier>Version â€“ Increments the project version classifier.") { String taskName ->
	if(taskName.startsWith('increment') && taskName.endsWith('Version')) {
		task(taskName) {
		
			doLast {			
					String classifier = (taskName - 'increment' - 'Version').toLowerCase()
					String currentVersion = version.toString()
					switch(classifier) {
						case 'major': ++version.major
							break
						case 'minor': ++version.minor
							break
						default: throw new GradleException("Invalid versiontype '$classifier. Allowed types:['Major', 'Minor']")
					}
					String newVersion = version.toString()
					logger.info "Incrementing $classifier project version:$currentVersion -> $newVersion"
					ant.propertyfile(file: versionFile) {
						entry(key: classifier, type: 'int', operation: '+', value: 1)
				}
			}
		}
	}
}

//4.2.11 Task Rules END

//4.3.1 Hooking into task execution graph BEGIN
task createDistribution2(type: Zip) { // NO MORE DOING USING DEPENDENCY //, dependsOn: makeReleaseVersion2) {
	from war.outputs.files
	from(sourceSets*.allSource) {
		into 'src'
	}
	from(rootDir) {
		include versionFile.name
	}
}

task backupReleaseDistribution2(type: Copy) {
	from createDistribution2.outputs.files
	into "$buildDir/backup"
}

task release2(dependsOn: backupReleaseDistribution2) {
	doLast {
		logger.quiet 'Releasing the project...'
	}
}

class ReleaseVersionListener implements TaskExecutionGraphListener {
	final static String releaseTaskPath = ':release2'
	
	@Override
	void graphPopulated(TaskExecutionGraph taskGraph) {
		println "graphPopulated CALLED"
		if(taskGraph.hasTask(releaseTaskPath)) {
			List<Task> allTasks = taskGraph.allTasks
			Task releaseTask = allTasks.find {it.path == releaseTaskPath }
			Project project = releaseTask.project
			if(!project.version.release) {
				project.version.release = true
				project.ant.propertyfile(file: project.versionFile) {
					entry(key: 'release', type: 'string', operation: '=', value: 'true')
				}
			}//if(!project
		}//if(taskGraph
	}//void graphPopulated
}//class

def releaseVersionListener = new ReleaseVersionListener()
gradle.taskGraph.addTaskExecutionGraphListener(releaseVersionListener)

//4.3.1 Hooking into task execution graph END

//5.3.2 BEGIN
configurations {
	cargo {
		description = 'Classpath for Cargo Ant tasks.'
		visible = false
	}
}
//5.3.2 END